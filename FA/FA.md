# CVE-2022-4262

Author: Jack Ren ([@bjrjk](https://github.com/bjrjk))

This V8 CVE is the one of the most difficult and non-trivial type confusion vulnerability I've ever met since I started to study JavaScript engine vulnerabilities. It has spent me more than two full weeks and numerous spare time to analyze this bug and try to find an exploit. However, I was only able to accomplish a [root cause analysis (in Chinese)<sup>1</sup>](#RefList-1) because of having no time to investigate this vulnerability anymore. That's really a pity I didn't have time to figure out the exploit myself.

However, the pity is finally settled down after [@mistymntncop](https://github.com/mistymntncop) using his brilliant intelligence to develop an [exploit<sup>2</sup>](#RefList-2). This exploit is so tricky and artful that I cannot suppress my thrilled feeling! @mistymntncop is really an V8 codebase auditing genius to develop this fragile exploit!

In order to preserve his precious thought and commemorate my time on this unruly CVE, I decide to write a full analysis on the vulnerability. This write up will divide the whole exploit process into different stages, each described in a section in this article, to make you readers easier to understand.

The article will be mainly made up of the following [6](TODO: Number of Technical Section) technical sections:
- [Overview](#overview): Because of the complicated root cause and the long exploit chain, an overview will be presented to help you have a rough understanding of this CVE and its possible attack impacts.
- [Proof of Concept](#proof-of-concept): This section delivers information about proof of concept, its runtime output and its sketchy runtime logic.
- [Root Cause Analysis](#root-cause-analysis): We'll figure out the root cause of this uncommon type confusion in function's feedback vector. This vulnerability is due to strictness mismatch in execution context, i.e. scope.
- [Simplified Exploit](#simplified-exploit): A simplified exploit will be provided and introduced to readers to make a better understanding of the formal exploit's key point.
- [Exploit Primitive in V8 Sandbox](#exploit-primitive-in-v8-sandbox): This section contains the JavaScript source utilizing the vulnerability to achieve Address-Of, Fake-Object, Read & Write Primitive in V8 Sandbox. Meanwhile it will also describe why the source's capable to do so.
- [Exploit for RCE (Possibly)](#exploit-for-rce): The insight to enlarge primitives in V8 Sandbox to Remote Code Execution in this specific vulnerability version of V8 will be presented.

Each section, except Overview, will contain multiple subsections. They are typically starting with background knowledges, then source code (PoC, Exploit) or patch, which is followed by a technology analysis upon it. Finally, a conclusion will summarize the whole section.

Now, let's start with Overview for CVE-2022-4262!

# Overview

In order to reduce V8's memory usage, a mechanism called [*Bytecode<sup>(1)</sup> flushing*<sup>3</sup>](#RefList-3) is implemented on V8 engine. The core idea of *Bytecode flushing* is to jettison unused function bytecodes when every major (mark-compact) GC<sup>(2)</sup> occured, as bytecode will consume lots of memory. However, the function's feedback vector<sup>(3)</sup> won't be recycled when the bytecode is being recycled.

There exists two execution mode for JavaScript, respectively named [*strict mode*<sup>4</sup>](#RefList-4) and *non-strict mode*, i.e. *sloppy mode*. From the very beginning of the proposing of JavaScript language to the publish of ECMAScript<sup>(4)</sup> 5 standard, all JavaScript script runs in *sloppy mode*. *Strict mode* is introduced by this new standard to strictify the semantic of JavaScript language. Due to the emerging of *strict mode*, a set of flags must be set up for [scopes<sup>5</sup>](#RefList-5) to indicate code in this scope runs in which mode.

[`eval()`<sup>6</sup>](#RefList-6) is one of the most important JavaScript builtin function. It provides the capability to dynamically execute JavaScript by passing a string argument of JavaScript code. The semantic of `eval` function is different between *strict mode* and *sloppy mode*. In *sloppy mode*, `eval` may introduce new variables into the surrounding scope. But in *strict mode*, `eval` won't introduce any new variables into the surrounding scope anymore[<sup>7</sup>](#RefList-7). In order to record whether the feature is enabled, a boolean field named `sloppy_eval_can_extend_vars_` is defined in class `Scope`.

Because of the invoking of GC in vulnerability PoC, the bytecode of PoC will be jettisoned, then recompiled immediately after GC finished. Theoretically, the bytecode before and after GC should be consistent. However, due to the implementation error of JavaScript code parser, the value of `sloppy_eval_can_extend_vars_` field in a specific `Scope` instance is inconsistent across two bytecode generation process, which lead to the inconsistency of bytecode.

The feedback vector's content is reserved between GC. However, due to the inconsistency of bytecode across GC, different kind of bytecode may correspond to the same feedback slot position in feedback vector, in which contains old bytecode's profile information. In that case, the feedback slot handler of new bytecode will try to decode information of old type with a totally different format, this is the time when type confusion happened.

> (1) Bytecode is an intermediate representation of the original JavaScript source, which is generated and used by V8 to accelerate the execution speed of JavaScript source. <br/>
> (2) GC, also named garbage collection, is to free unused object in currrent execution context to relieve memory pressure and reserve space for other new objects. <br/>
> (3) Feedback vector is a data structure being used to profile (cache) the object and method had ever used in the current function to speed up the execution upon the future invocation of current function. Some type of bytecode may use feedback slots in feedback vector to accelerate their execution. <br/>
> (4) ECMAScript is the language specification of JavaScript.

# Proof of Concept

# Root Cause Analysis

# Simplified Exploit

# Exploit Primitive in V8 Sandbox

# Exploit for RCE

# Conclusion

# Reference
1. <a id="RefList-1" href="https://github.com/bjrjk/CVE-2022-4262/blob/main/RCA/RCA.md">CVE-2022-4262/RCA/RCA.md at main · bjrjk/CVE-2022-4262</a>
2. <a id="RefList-2" href="https://github.com/mistymntncop/CVE-2022-4262">mistymntncop/CVE-2022-4262</a>
3. <a id="RefList-3" href="https://v8.dev/blog/v8-lite#bytecode-flushing">Bytecode flushing - A lighter V8 · V8</a>
4. <a id="RefList-4" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode">Strict mode - JavaScript | MDN</a>
5. <a id="RefList-5" href="https://developer.mozilla.org/en-US/docs/Glossary/Scope">Scope - MDN Web Docs Glossary: Definitions of Web-related terms | MDN</a>
6. <a id="RefList-6" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval">eval() - JavaScript | MDN</a>
7. <a id="RefList-7" href="https://whereswalden.com/2011/01/10/new-es5-strict-mode-support-new-vars-created-by-strict-mode-eval-code-are-local-to-that-code-only/">Where&#039;s Walden? &raquo; New ES5 strict mode support: new vars created by strict mode eval code are local to that code only</a>
